// Generated by CoffeeScript 1.3.3
(function() {
  var ParsedMessage;

  ParsedMessage = (function() {
    var DESCRIBE_TYPE, IT_BLOCK_START, IT_TYPE, PASSED_IT_BLOCK;

    IT_BLOCK_START = '[3';

    PASSED_IT_BLOCK = '2';

    IT_TYPE = 'it';

    DESCRIBE_TYPE = 'describe';

    function ParsedMessage(message, projectName) {
      this.projectName = projectName;
      this.isSyntaxError = false;
      this.isSpecs = false;
      this.errorIndex = 0;
      this.parse(message);
    }

    ParsedMessage.prototype.parse = function(message) {
      if (this.containsSyntaxError(message)) {
        return this.isSyntaxError = true;
      } else {
        return this.parseTestResults(message);
      }
    };

    ParsedMessage.prototype.containsSyntaxError = function(message) {
      return message.indexOf('SyntaxError:') !== -1;
    };

    ParsedMessage.prototype.parseTestResults = function(message) {
      var failureStacktraces, verboseSpecs;
      this.failedTests = [];
      this.isSpecs = true;
      failureStacktraces = this.extractStackTrace(message);
      if (failureStacktraces != null) {
        verboseSpecs = this.extractVerboseSpecsFailed(message);
      } else {
        verboseSpecs = this.extractVerboseSpecsPassed(message);
      }
      return this.extractFailureInformation(verboseSpecs, failureStacktraces);
    };

    ParsedMessage.prototype.extractVerboseSpecsFailed = function(message) {
      return message.match(/(.+\n\n.+\n.\[3[12]m[\s\S]*)Failures:\s/m)[1];
    };

    ParsedMessage.prototype.extractVerboseSpecsPassed = function(message) {
      return message.match(/(.+\n\n.+\n.\[3[12]m[\s\S]*)Finished in\s/m)[1];
    };

    ParsedMessage.prototype.extractStackTrace = function(message) {
      var stacktrace;
      stacktrace = message.match(/Failures:\s([\s\S]*)\n+Finished in/m);
      if (stacktrace != null) {
        return stacktrace[1];
      } else {
        return null;
      }
    };

    ParsedMessage.prototype.parseFailures = function(message) {
      return message.match(/(.+\n.\[3[12]m[\s\S]*)Failures:\s([\s\S]*)\n+Finished/m);
    };

    ParsedMessage.prototype.extractFailureInformation = function(verboseSpecs, failureStacktraces) {
      var line, lines, _i, _len;
      if (failureStacktraces != null) {
        this.extractErrorInformation(failureStacktraces);
      }
      this.specs = [];
      lines = verboseSpecs.split("\n");
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        this.parseSpecLine(line);
      }
      return this.sanitizeSpecs;
    };

    ParsedMessage.prototype.parseSpecLine = function(line) {
      var match, spec, specName;
      if (match = line.match(/^(\w+)/)) {
        specName = match[1];
        spec = {
          specName: specName,
          children: [],
          passed: true
        };
        return this.specs.push(spec);
      } else {
        if (this.isItBlock(line)) {
          return this.addItBlock(line, this.currentSpec());
        } else {
          return this.addDescribeBlock(line, this.currentSpec());
        }
      }
    };

    ParsedMessage.prototype.currentSpec = function() {
      return this.specs[this.specs.length - 1];
    };

    ParsedMessage.prototype.isItBlock = function(line) {
      return line.match(/\[3\dm\s/);
    };

    ParsedMessage.prototype.addItBlock = function(line, spec) {
      var error, itBlock, message, passed;
      message = line.match(/\[3[12]m\s*([\s\S]+).\[0m/)[1];
      if (this.isPassedSpec(line)) {
        passed = true;
        error = null;
      } else {
        passed = false;
        spec.passed = false;
        this.failedTests.push(spec.specName);
        error = this.findCorrespondingError(message);
      }
      itBlock = {
        message: message,
        passed: passed,
        type: IT_TYPE,
        error: error
      };
      return spec.children.push(itBlock);
    };

    ParsedMessage.prototype.findCorrespondingError = function(message) {
      var match;
      console.log(this.errors);
      match = this.errors[this.errorIndex];
      this.errorIndex++;
      return match;
    };

    ParsedMessage.prototype.addDescribeBlock = function(line, spec) {
      console.log('Ignoring describes for now');
      return null;
    };

    ParsedMessage.prototype.isPassedSpec = function(line) {
      return line.indexOf(IT_BLOCK_START + PASSED_IT_BLOCK) !== -1;
    };

    ParsedMessage.prototype.extractBlockInformation = function(verboseSpecs) {
      console.log('ignoring blocks for now');
      return null;
    };

    ParsedMessage.prototype.extractSpecName = function(verboseSpecs) {
      var specName;
      return specName = verboseSpecs.match(/(\S+)\s/)[1];
    };

    ParsedMessage.prototype.extractErrorInformation = function(failureStacktraces) {
      var failures,
        _this = this;
      this.errors = [];
      failures = failureStacktraces.split("\n\n");
      return failures.each(function(failure) {
        var error;
        error = _this.parseFailure(failure);
        return _this.errors.push(error);
      });
    };

    ParsedMessage.prototype.parseFailure = function(failure) {
      var error, matches, message, stacktrace;
      matches = failure.match(/Message:\s([\s\S]+?)Stacktrace:[\s\S]*?(at[\s\S]*)/m);
      message = matches[1];
      stacktrace = matches[2];
      error = this.parseStackTrace(stacktrace);
      error.message = this.sanitizeErrorMessage(message);
      return error;
    };

    ParsedMessage.prototype.parseStackTrace = function(stacktrace) {
      var error, traces,
        _this = this;
      traces = stacktrace.split("\n");
      error = null;
      traces.each(function(trace) {
        var errorLine;
        if ((trace.indexOf('node_modules') === -1) && (trace.indexOf(_this.projectName) >= 0) && !error) {
          errorLine = _this.parseTrace(trace);
          return error = _this.parseError(errorLine);
        }
      });
      return error;
    };

    ParsedMessage.prototype.parseTrace = function(trace) {
      var errorLine;
      return errorLine = trace.match(new RegExp(this.projectName + '(.+).'))[1];
    };

    ParsedMessage.prototype.parseError = function(errorLine) {
      var error, errorParts;
      errorParts = errorLine.split(':');
      error = {
        filePath: errorParts[0],
        fileName: this.fileNameFromPath(errorParts[0]),
        line: errorParts[1],
        column: errorParts[2]
      };
      return error;
    };

    ParsedMessage.prototype.fileNameFromPath = function(filePath) {
      return filePath.slice(filePath.lastIndexOf('/') + 1, filePath.indexOf('.'));
    };

    ParsedMessage.prototype.sanitizeErrorMessage = function(message) {
      var matches;
      matches = message.match(/\[31m(.+)\[\d+m/);
      return matches[1];
    };

    ParsedMessage.prototype.sanitizeSpecs = function() {
      var cleanSpecs;
      cleanSpecs = [];
      this.specs.each(function(spec) {
        if (spec.children.length > 0) {
          return cleanSpecs.push(spec);
        }
      });
      return this.specs = cleanSpecs;
    };

    return ParsedMessage;

  })();

  define(function(require, exports, module) {
    return exports.ParsedMessage = ParsedMessage;
  });

}).call(this);
